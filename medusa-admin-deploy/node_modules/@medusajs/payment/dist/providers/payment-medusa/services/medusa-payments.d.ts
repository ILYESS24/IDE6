import stripe from "stripe";
import { AuthorizePaymentInput, AuthorizePaymentOutput, CancelPaymentInput, CancelPaymentOutput, CapturePaymentInput, CapturePaymentOutput, RetrieveAccountHolderInput, RetrieveAccountHolderOutput, CreateAccountHolderInput, CreateAccountHolderOutput, DeleteAccountHolderInput, DeleteAccountHolderOutput, DeletePaymentInput, DeletePaymentOutput, GetPaymentStatusInput, GetPaymentStatusOutput, InitiatePaymentInput, InitiatePaymentOutput, ListPaymentMethodsInput, ListPaymentMethodsOutput, ProviderWebhookPayload, RefundPaymentInput, RefundPaymentOutput, RetrievePaymentInput, RetrievePaymentOutput, SavePaymentMethodInput, SavePaymentMethodOutput, UpdateAccountHolderInput, UpdateAccountHolderOutput, UpdatePaymentInput, UpdatePaymentOutput, WebhookActionResult } from "@medusajs/framework/types";
import { AbstractPaymentProvider } from "@medusajs/framework/utils";
import { MedusaPaymentsOptions } from "../types";
import { CreatePaymentRequest } from "../types/medusa-payments";
type HandledErrorType = {
    retry: true;
} | {
    retry: false;
    data: any;
};
declare class CloudServiceError extends Error {
    type: string;
    originalType: string;
    data: any;
    message: string;
    constructor(type: string, originalType: string, data: any, message: string);
}
export declare class MedusaPaymentsProvider extends AbstractPaymentProvider<MedusaPaymentsOptions> {
    static identifier: string;
    protected readonly options_: MedusaPaymentsOptions;
    protected container_: Record<string, unknown>;
    protected readonly stripeClient: stripe;
    static validateOptions(options: MedusaPaymentsOptions): void;
    constructor(cradle: Record<string, unknown>, options: MedusaPaymentsOptions);
    request<T>(url: string, options: Omit<RequestInit, "body"> & {
        body?: object;
    }): Promise<T>;
    normalizePaymentParameters(extra?: Record<string, string>): Partial<CreatePaymentRequest>;
    handleStripeError(error: CloudServiceError): HandledErrorType;
    executeWithRetry<T>(apiCall: () => Promise<T>, maxRetries?: number, baseDelay?: number, currentAttempt?: number): Promise<T>;
    getPaymentStatus(input: GetPaymentStatusInput): Promise<GetPaymentStatusOutput>;
    initiatePayment({ currency_code, amount, data, context, }: InitiatePaymentInput): Promise<InitiatePaymentOutput>;
    authorizePayment(input: AuthorizePaymentInput): Promise<AuthorizePaymentOutput>;
    cancelPayment({ data, context, }: CancelPaymentInput): Promise<CancelPaymentOutput>;
    capturePayment({ data, context, }: CapturePaymentInput): Promise<CapturePaymentOutput>;
    deletePayment(input: DeletePaymentInput): Promise<DeletePaymentOutput>;
    refundPayment({ amount, data, context, }: RefundPaymentInput): Promise<RefundPaymentOutput>;
    retrievePayment({ data, }: RetrievePaymentInput): Promise<RetrievePaymentOutput>;
    updatePayment({ data, currency_code, amount, context, }: UpdatePaymentInput): Promise<UpdatePaymentOutput>;
    retrieveAccountHolder({ id, }: RetrieveAccountHolderInput): Promise<RetrieveAccountHolderOutput>;
    createAccountHolder({ context, }: CreateAccountHolderInput): Promise<CreateAccountHolderOutput>;
    updateAccountHolder({ context, }: UpdateAccountHolderInput): Promise<UpdateAccountHolderOutput>;
    deleteAccountHolder({ context, }: DeleteAccountHolderInput): Promise<DeleteAccountHolderOutput>;
    listPaymentMethods({ context, }: ListPaymentMethodsInput): Promise<ListPaymentMethodsOutput>;
    savePaymentMethod({ context, data, }: SavePaymentMethodInput): Promise<SavePaymentMethodOutput>;
    private getStatus;
    getWebhookActionAndData(webhookData: ProviderWebhookPayload["payload"]): Promise<WebhookActionResult>;
    /**
     * Constructs Medusa Payments Webhook event
     * @param {object} data - the data of the webhook request: req.body
     *    ensures integrity of the webhook event
     * @return {object} Medusa Payments Webhook event
     */
    constructWebhookEvent(data: ProviderWebhookPayload["payload"]): stripe.Event;
}
export {};
//# sourceMappingURL=medusa-payments.d.ts.map