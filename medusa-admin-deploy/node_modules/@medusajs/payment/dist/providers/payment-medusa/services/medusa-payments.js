"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MedusaPaymentsProvider = void 0;
const promises_1 = require("timers/promises");
const stripe_1 = __importDefault(require("stripe"));
const utils_1 = require("@medusajs/framework/utils");
const get_smallest_unit_1 = require("../utils/get-smallest-unit");
class CloudServiceError extends Error {
    constructor(type, originalType, data, message) {
        super(message);
        this.type = type;
        this.originalType = originalType;
        this.data = data;
        this.message = message;
    }
}
class MedusaPaymentsProvider extends utils_1.AbstractPaymentProvider {
    // The provider is loaded in a different a bit differently - it is not passed as a provider but the options are passed to the module's configuration.
    // Due to that, the validation needs to happen in the constructor
    static validateOptions(options) {
        return validateOptions(options);
    }
    constructor(cradle, options) {
        super(cradle, options);
        validateOptions(options ?? {});
        this.options_ = options;
        this.stripeClient = new stripe_1.default(options.api_key);
    }
    request(url, options) {
        const headers = {
            "Content-Type": "application/json",
            Authorization: `Basic ${this.options_.api_key}`,
        };
        if (this.options_.environment_handle) {
            headers["x-medusa-environment-handle"] = this.options_.environment_handle;
        }
        if (this.options_.sandbox_handle) {
            headers["x-medusa-sandbox-handle"] = this.options_.sandbox_handle;
        }
        return fetch(`${this.options_.endpoint}${url}`, {
            ...options,
            body: options.body ? JSON.stringify(options.body) : undefined,
            headers: {
                ...options.headers,
                ...headers,
            },
        }).then(async (res) => {
            const body = await res.json().catch(() => ({}));
            if (!res.ok) {
                throw new CloudServiceError(body.type, body.originalType, body.data, body.message);
            }
            return body;
        });
    }
    normalizePaymentParameters(extra) {
        const res = {
            description: extra?.payment_description ?? "",
            capture_method: extra?.capture_method,
            setup_future_usage: extra?.setup_future_usage,
            payment_method_types: extra?.payment_method_types,
            payment_method_data: extra?.payment_method_data,
            payment_method_options: extra?.payment_method_options,
            automatic_payment_methods: extra?.automatic_payment_methods,
            off_session: extra?.off_session,
            confirm: extra?.confirm,
            payment_method: extra?.payment_method,
            return_url: extra?.return_url,
            shared_payment_token: extra?.shared_payment_token,
        };
        return res;
    }
    handleStripeError(error) {
        let medusaPayment;
        switch (error.type) {
            case "MedusaCardError":
                // Medusa has created a payment but it failed
                // Extract and return payment object to be stored in payment_session
                // Allows for reference to the failed intent and potential webhook reconciliation
                medusaPayment = error.data;
                if (medusaPayment) {
                    return {
                        retry: false,
                        data: medusaPayment,
                    };
                }
                else {
                    throw error;
                }
            case "MedusaPaymentUnexpectedStateError":
                medusaPayment = error.data;
                if (medusaPayment) {
                    return {
                        retry: false,
                        data: medusaPayment,
                    };
                }
                else {
                    throw error;
                }
            case "MedusaConnectionError":
            case "MedusaRateLimitError":
                // Connection or rate limit errors indicate an uncertain result
                // Retry the operation
                return {
                    retry: true,
                };
            case "MedusaAPIError": {
                // API errors should be treated as indeterminate per Stripe documentation
                // Rely on webhooks rather than assuming failure
                return {
                    retry: false,
                    data: {
                        indeterminate_due_to: "medusa_api_error",
                    },
                };
            }
            default:
                throw error;
        }
    }
    async executeWithRetry(apiCall, maxRetries = 3, baseDelay = 1000, currentAttempt = 1) {
        try {
            return await apiCall();
        }
        catch (error) {
            const handledError = this.handleStripeError(error);
            if (!handledError.retry) {
                // If retry is false, we know data exists per the type definition
                return handledError.data;
            }
            if (handledError.retry && currentAttempt <= maxRetries) {
                // Logic for retrying
                const delay = baseDelay *
                    Math.pow(2, currentAttempt - 1) *
                    (0.5 + Math.random() * 0.5);
                await (0, promises_1.setTimeout)(delay);
                return this.executeWithRetry(apiCall, maxRetries, baseDelay, currentAttempt + 1);
            }
            // Retries are exhausted
            throw error;
        }
    }
    async getPaymentStatus(input) {
        const id = input?.data?.id;
        if (!id) {
            throw new Error("No payment intent ID provided while getting payment status");
        }
        const payment = await this.retrievePayment({ data: { id } });
        const statusResponse = this.getStatus(payment.data);
        return statusResponse;
    }
    async initiatePayment({ currency_code, amount, data, context, }) {
        const additionalParameters = this.normalizePaymentParameters(data);
        const intentRequest = {
            amount: (0, get_smallest_unit_1.getSmallestUnit)(amount, currency_code),
            currency: currency_code,
            metadata: {
                session_id: data?.session_id,
            },
            account_holder_id: context?.account_holder?.data?.id,
            idempotency_key: context?.idempotency_key,
            ...additionalParameters,
        };
        const payment = (await this.executeWithRetry(() => {
            return this.request("/payments", {
                method: "POST",
                body: intentRequest,
            }).then((data) => data.payment);
        }));
        return {
            id: payment.id,
            ...this.getStatus(payment),
        };
    }
    async authorizePayment(input) {
        return this.getPaymentStatus(input);
    }
    async cancelPayment({ data, context, }) {
        const id = data?.id;
        if (!id) {
            return { data: data };
        }
        const intent = (await this.executeWithRetry(() => {
            return this.request(`/payments/${id}/cancel`, {
                method: "POST",
                body: {
                    idempotency_key: context?.idempotency_key,
                },
            }).then((data) => data.payment);
        }));
        const status = this.getStatus(intent);
        if (status.status !== utils_1.PaymentSessionStatus.CANCELED) {
            throw new Error(`Payment with id ${id} could not be canceled. Status: ${status.status}`);
        }
        return { data: intent };
    }
    async capturePayment({ data, context, }) {
        const id = data?.id;
        const intent = (await this.executeWithRetry(() => {
            return this.request(`/payments/${id}/capture`, {
                method: "POST",
                body: {
                    idempotency_key: context?.idempotency_key,
                },
            }).then((data) => data.payment);
        }));
        const status = this.getStatus(intent);
        if (status.status !== utils_1.PaymentSessionStatus.CAPTURED) {
            throw new Error(`Payment with id ${id} could not be captured. Status: ${status.status}`);
        }
        return { data: intent };
    }
    async deletePayment(input) {
        return await this.cancelPayment(input);
    }
    async refundPayment({ amount, data, context, }) {
        const id = data?.id;
        if (!id) {
            throw new Error("No payment intent ID provided while refunding payment");
        }
        const currencyCode = data?.currency;
        const response = (await this.executeWithRetry(() => {
            return this.request(`/payments/${id}/refund`, {
                method: "POST",
                body: {
                    amount: (0, get_smallest_unit_1.getSmallestUnit)(amount, currencyCode),
                    idempotency_key: context?.idempotency_key,
                },
            }).then((data) => data.refund);
        }));
        return { data: response };
    }
    async retrievePayment({ data, }) {
        const id = data?.id;
        const intent = (await this.executeWithRetry(() => {
            return this.request(`/payments/${id}`, {
                method: "GET",
            }).then((data) => data.payment);
        }));
        intent.amount = (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount, intent.currency);
        return { data: intent };
    }
    async updatePayment({ data, currency_code, amount, context, }) {
        const amountNumeric = (0, get_smallest_unit_1.getSmallestUnit)(amount, currency_code);
        if ((0, utils_1.isPresent)(amount) && data?.amount === amountNumeric) {
            return this.getStatus(data);
        }
        const id = data?.id;
        const sessionData = (await this.executeWithRetry(() => {
            return this.request(`/payments/${id}`, {
                method: "POST",
                body: {
                    amount: amountNumeric,
                    idempotency_key: context?.idempotency_key,
                },
            }).then((data) => data.payment);
        }));
        return this.getStatus(sessionData);
    }
    async retrieveAccountHolder({ id, }) {
        if (!id) {
            throw new Error("No account holder ID provided while getting account holder");
        }
        const res = (await this.executeWithRetry(() => {
            return this.request(`/account-holders/${id}`, {
                method: "GET",
            }).then((data) => data.account_holder);
        }));
        return {
            id: res.id,
            data: res,
        };
    }
    async createAccountHolder({ context, }) {
        const { account_holder, customer, idempotency_key } = context;
        if (account_holder?.data?.id) {
            return { id: account_holder.data.id };
        }
        if (!customer) {
            throw new Error("No customer provided while creating account holder");
        }
        const shipping = customer.billing_address
            ? {
                address: {
                    city: customer.billing_address.city,
                    country: customer.billing_address.country_code,
                    line1: customer.billing_address.address_1,
                    line2: customer.billing_address.address_2,
                    postal_code: customer.billing_address.postal_code,
                    state: customer.billing_address.province,
                },
            }
            : undefined;
        const accountHolder = (await this.executeWithRetry(() => {
            return this.request(`/account-holders`, {
                method: "POST",
                body: {
                    email: customer.email,
                    name: customer.company_name ||
                        `${customer.first_name ?? ""} ${customer.last_name ?? ""}`.trim() ||
                        undefined,
                    phone: customer.phone,
                    ...shipping,
                    idempotency_key: idempotency_key,
                },
            }).then((data) => data.account_holder);
        }));
        return {
            id: accountHolder.id,
            data: accountHolder,
        };
    }
    async updateAccountHolder({ context, }) {
        const { account_holder, customer, idempotency_key } = context;
        if (!account_holder?.data?.id) {
            throw new Error("No account holder in context while updating account holder");
        }
        // If no customer context was provided, we simply don't update anything within the provider
        if (!customer) {
            return {};
        }
        const accountHolderId = account_holder.data.id;
        const shipping = customer.billing_address
            ? {
                address: {
                    city: customer.billing_address.city,
                    country: customer.billing_address.country_code,
                    line1: customer.billing_address.address_1,
                    line2: customer.billing_address.address_2,
                    postal_code: customer.billing_address.postal_code,
                    state: customer.billing_address.province,
                },
            }
            : undefined;
        const accountHolder = (await this.executeWithRetry(() => {
            return this.request(`/account-holders/${accountHolderId}`, {
                method: "POST",
                body: {
                    email: customer.email,
                    name: customer.company_name ||
                        `${customer.first_name ?? ""} ${customer.last_name ?? ""}`.trim() ||
                        undefined,
                    phone: customer.phone,
                    ...shipping,
                    idempotency_key: idempotency_key,
                },
            }).then((data) => data.account_holder);
        }));
        return {
            data: accountHolder,
        };
    }
    async deleteAccountHolder({ context, }) {
        const { account_holder } = context;
        const accountHolderId = account_holder?.data?.id;
        if (!accountHolderId) {
            throw new Error("No account holder in context while deleting account holder");
        }
        await this.executeWithRetry(() => {
            return this.request(`/account-holders/${accountHolderId}`, {
                method: "DELETE",
            });
        });
        return {};
    }
    async listPaymentMethods({ context, }) {
        const accountHolderId = context?.account_holder?.data?.id;
        if (!accountHolderId) {
            return [];
        }
        const paymentMethods = (await this.executeWithRetry(() => {
            return this.request(`/payment-methods?account_holder_id=${accountHolderId}`, {
                method: "GET",
            }).then((data) => data.payment_methods);
        }));
        return paymentMethods.map((method) => ({
            id: method.id,
            data: method,
        }));
    }
    async savePaymentMethod({ context, data, }) {
        const accountHolderId = context?.account_holder?.data?.id;
        if (!accountHolderId) {
            throw new Error("Account holder not set while saving a payment method");
        }
        const paymentMethodSession = (await this.executeWithRetry(() => {
            return this.request(`/payment-methods`, {
                method: "POST",
                body: {
                    account_holder_id: accountHolderId,
                    ...data,
                    idempotency_key: context?.idempotency_key,
                },
            }).then((data) => data.payment_method_session);
        }));
        return {
            id: paymentMethodSession.id,
            data: paymentMethodSession,
        };
    }
    getStatus(payment) {
        const paymenAsRecord = payment;
        switch (payment.status) {
            case "requires_payment_method":
                if (payment.last_payment_error) {
                    return { status: utils_1.PaymentSessionStatus.ERROR, data: paymenAsRecord };
                }
                return { status: utils_1.PaymentSessionStatus.PENDING, data: paymenAsRecord };
            case "requires_confirmation":
            case "processing":
                return { status: utils_1.PaymentSessionStatus.PENDING, data: paymenAsRecord };
            case "requires_action":
                return {
                    status: utils_1.PaymentSessionStatus.REQUIRES_MORE,
                    data: paymenAsRecord,
                };
            case "canceled":
                return { status: utils_1.PaymentSessionStatus.CANCELED, data: paymenAsRecord };
            case "requires_capture":
                return { status: utils_1.PaymentSessionStatus.AUTHORIZED, data: paymenAsRecord };
            case "succeeded":
                return { status: utils_1.PaymentSessionStatus.CAPTURED, data: paymenAsRecord };
            default:
                return { status: utils_1.PaymentSessionStatus.PENDING, data: paymenAsRecord };
        }
    }
    async getWebhookActionAndData(webhookData) {
        const event = this.constructWebhookEvent(webhookData);
        const intent = event.data.object;
        const { currency } = intent;
        switch (event.type) {
            case "payment_intent.created":
            case "payment_intent.processing":
                return {
                    action: utils_1.PaymentActions.PENDING,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount, currency),
                    },
                };
            case "payment_intent.canceled":
                return {
                    action: utils_1.PaymentActions.CANCELED,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount, currency),
                    },
                };
            case "payment_intent.payment_failed":
                return {
                    action: utils_1.PaymentActions.FAILED,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount, currency),
                    },
                };
            case "payment_intent.requires_action":
                return {
                    action: utils_1.PaymentActions.REQUIRES_MORE,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount, currency),
                    },
                };
            case "payment_intent.amount_capturable_updated":
                return {
                    action: utils_1.PaymentActions.AUTHORIZED,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount_capturable, currency),
                    },
                };
            case "payment_intent.partially_funded":
                return {
                    action: utils_1.PaymentActions.REQUIRES_MORE,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.next_action?.display_bank_transfer_instructions
                            ?.amount_remaining ?? intent.amount, currency),
                    },
                };
            case "payment_intent.succeeded":
                return {
                    action: utils_1.PaymentActions.SUCCESSFUL,
                    data: {
                        session_id: intent.metadata.session_id,
                        amount: (0, get_smallest_unit_1.getAmountFromSmallestUnit)(intent.amount_received, currency),
                    },
                };
            default:
                return { action: utils_1.PaymentActions.NOT_SUPPORTED };
        }
    }
    /**
     * Constructs Medusa Payments Webhook event
     * @param {object} data - the data of the webhook request: req.body
     *    ensures integrity of the webhook event
     * @return {object} Medusa Payments Webhook event
     */
    constructWebhookEvent(data) {
        const signature = data.headers["medusa-payments-signature"];
        const stripeEvent = this.stripeClient.webhooks.constructEvent(data.rawData, signature, this.options_.webhook_secret);
        return stripeEvent;
    }
}
exports.MedusaPaymentsProvider = MedusaPaymentsProvider;
MedusaPaymentsProvider.identifier = "medusa-payments";
const validateOptions = (options) => {
    if (!(0, utils_1.isDefined)(options.endpoint)) {
        throw new Error("Required option `endpoint` is missing in Medusa payments plugin");
    }
    if (!(0, utils_1.isDefined)(options.webhook_secret)) {
        throw new Error("Required option `webhook_secret` is missing in Medusa payments plugin");
    }
    if (!(0, utils_1.isDefined)(options.api_key)) {
        throw new Error("Required option `api_key` is missing in Medusa payments plugin");
    }
    if (!(0, utils_1.isDefined)(options.environment_handle) &&
        !(0, utils_1.isDefined)(options.sandbox_handle)) {
        throw new Error("Required option `environment_handle` or `sandbox_handle` is missing in Medusa payments plugin");
    }
};
//# sourceMappingURL=medusa-payments.js.map