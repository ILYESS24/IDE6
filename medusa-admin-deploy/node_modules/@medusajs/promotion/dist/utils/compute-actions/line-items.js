"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComputedActionsForItems = getComputedActionsForItems;
const utils_1 = require("@medusajs/framework/utils");
const validations_1 = require("../validations");
const sort_by_price_1 = require("./sort-by-price");
const usage_1 = require("./usage");
function validateContext(contextKey, context) {
    if (!context) {
        throw new utils_1.MedusaError(utils_1.MedusaError.Types.INVALID_DATA, `"${contextKey}" should be present as an array in the context for computeActions`);
    }
}
function getComputedActionsForItems(promotion, items, appliedPromotionsMap, allocationOverride) {
    validateContext("items", items);
    return applyPromotionToItems(promotion, items, appliedPromotionsMap, allocationOverride);
}
function applyPromotionToItems(promotion, items, appliedPromotionsMap, allocationOverride) {
    const { application_method: applicationMethod } = promotion;
    if (!applicationMethod) {
        return [];
    }
    const allocation = applicationMethod?.allocation || allocationOverride;
    const target = applicationMethod?.target_type;
    if (!items?.length || !target) {
        return [];
    }
    const computedActions = [];
    let applicableItems = getValidItemsForPromotion(items, promotion);
    if (!applicableItems.length) {
        return computedActions;
    }
    if (allocation === utils_1.ApplicationMethodAllocation.ONCE) {
        applicableItems = applicableItems.sort(sort_by_price_1.sortLineItemByPriceAscending);
    }
    const isTargetLineItems = target === utils_1.ApplicationMethodTargetType.ITEMS;
    const isTargetOrder = target === utils_1.ApplicationMethodTargetType.ORDER;
    const promotionValue = applicationMethod?.value ?? 0;
    const maxQuantity = applicationMethod?.max_quantity;
    let remainingQuota = maxQuantity ?? 0;
    let lineItemsAmount = utils_1.MathBN.convert(0);
    if (allocation === utils_1.ApplicationMethodAllocation.ACROSS) {
        lineItemsAmount = applicableItems.reduce((acc, item) => utils_1.MathBN.sub(utils_1.MathBN.add(acc, promotion.is_tax_inclusive ? item.original_total : item.subtotal), appliedPromotionsMap.get(item.id) ?? 0), utils_1.MathBN.convert(0));
        if (utils_1.MathBN.lte(lineItemsAmount, 0)) {
            return computedActions;
        }
    }
    for (const item of applicableItems) {
        if (allocation === utils_1.ApplicationMethodAllocation.ONCE &&
            remainingQuota <= 0) {
            break;
        }
        if (utils_1.MathBN.lte(promotion.is_tax_inclusive ? item.original_total : item.subtotal, 0)) {
            continue;
        }
        const appliedPromoValue = appliedPromotionsMap.get(item.id) ?? 0;
        const effectiveMaxQuantity = allocation === utils_1.ApplicationMethodAllocation.ONCE
            ? Math.min(remainingQuota ?? 0, Number(item.quantity))
            : maxQuantity;
        // If the allocation is once, we rely on the existing logic for each allocation, as the calculate is the same: apply the promotion value to the line item
        const effectiveAllocation = allocation === utils_1.ApplicationMethodAllocation.ONCE
            ? utils_1.ApplicationMethodAllocation.EACH
            : allocation;
        const amount = (0, utils_1.calculateAdjustmentAmountFromPromotion)(item, {
            value: promotionValue,
            applied_value: appliedPromoValue,
            is_tax_inclusive: promotion.is_tax_inclusive,
            max_quantity: effectiveMaxQuantity,
            type: applicationMethod?.type,
            allocation: effectiveAllocation,
        }, lineItemsAmount);
        if (utils_1.MathBN.lte(amount, 0)) {
            continue;
        }
        const budgetExceededAction = (0, usage_1.computeActionForBudgetExceeded)(promotion, amount);
        if (budgetExceededAction) {
            computedActions.push(budgetExceededAction);
            continue;
        }
        appliedPromotionsMap.set(item.id, utils_1.MathBN.add(appliedPromoValue, amount));
        if (allocation === utils_1.ApplicationMethodAllocation.ONCE) {
            // We already know exactly how many units we applied via effectiveMaxQuantity
            const quantityApplied = Math.min(effectiveMaxQuantity, Number(item.quantity));
            remainingQuota -= quantityApplied;
        }
        if (isTargetLineItems || isTargetOrder) {
            computedActions.push({
                action: utils_1.ComputedActions.ADD_ITEM_ADJUSTMENT,
                item_id: item.id,
                amount,
                code: promotion.code,
                is_tax_inclusive: promotion.is_tax_inclusive,
            });
        }
    }
    return computedActions;
}
function getValidItemsForPromotion(items, promotion) {
    if (!items?.length || !promotion?.application_method) {
        return [];
    }
    const isTargetShippingMethod = promotion.application_method?.target_type === utils_1.ApplicationMethodTargetType.SHIPPING_METHODS;
    const targetRules = promotion.application_method?.target_rules ?? [];
    const hasTargetRules = targetRules.length > 0;
    if (isTargetShippingMethod && !hasTargetRules) {
        return items.filter((item) => item && "subtotal" in item && utils_1.MathBN.gt(item.subtotal, 0));
    }
    return items.filter((item) => {
        if (!item) {
            return false;
        }
        if ("is_discountable" in item && !item.is_discountable) {
            return false;
        }
        if (!("subtotal" in item) || utils_1.MathBN.lte(item.subtotal, 0)) {
            return false;
        }
        if (!isTargetShippingMethod && !("quantity" in item)) {
            return false;
        }
        if (!hasTargetRules) {
            return true;
        }
        return (0, validations_1.areRulesValidForContext)(promotion?.application_method?.target_rules, item, utils_1.ApplicationMethodTargetType.ITEMS);
    });
}
//# sourceMappingURL=line-items.js.map