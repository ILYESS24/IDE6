"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IndexModuleService_isWorkerMode;
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@medusajs/framework/utils");
const _models_1 = require("../models");
const _types_1 = require("../types");
const _utils_1 = require("../utils");
const base_graphql_schema_1 = require("../utils/base-graphql-schema");
class IndexModuleService extends utils_1.ModulesSdkUtils.MedusaService({}) {
    get indexMetadataService_() {
        return this.container_.indexMetadataService;
    }
    get indexSyncService_() {
        return this.container_.indexSyncService;
    }
    get dataSynchronizer_() {
        return this.container_.dataSynchronizer;
    }
    get logger_() {
        try {
            return this.container_.logger;
        }
        catch (e) {
            return console;
        }
    }
    constructor(container, moduleOptions, moduleDeclaration) {
        super(...arguments);
        this.moduleDeclaration = moduleDeclaration;
        _IndexModuleService_isWorkerMode.set(this, false);
        this.__hooks = {
            onApplicationStart() {
                return this.onApplicationStart_();
            },
        };
        this.baseRepository_ = container.baseRepository;
        this.container_ = container;
        this.moduleOptions_ = (moduleOptions ??
            moduleDeclaration.options ??
            moduleDeclaration);
        __classPrivateFieldSet(this, _IndexModuleService_isWorkerMode, moduleDeclaration.worker_mode !== "server", "f");
        const { [utils_1.Modules.EVENT_BUS]: eventBusModuleService, storageProviderCtr, storageProviderCtrOptions, } = container;
        this.eventBusModuleService_ = eventBusModuleService;
        this.storageProviderCtr_ = storageProviderCtr;
        this.storageProviderCtrOptions_ = storageProviderCtrOptions;
        if (!this.eventBusModuleService_) {
            throw new Error("EventBusModuleService is required for the IndexModule to work");
        }
    }
    async onApplicationStart_() {
        try {
            const executableSchema = this.buildSchemaObjectRepresentation_();
            this.storageProvider_ = new this.storageProviderCtr_(this.container_, Object.assign(this.storageProviderCtrOptions_ ?? {}, {
                schemaObjectRepresentation: this.schemaObjectRepresentation_,
                entityMap: this.schemaEntitiesMap_,
            }), this.moduleOptions_);
            this.registerListeners();
            if (this.storageProvider_.onApplicationStart) {
                await this.storageProvider_.onApplicationStart();
            }
            await (0, _utils_1.gqlSchemaToTypes)(executableSchema);
            /**
             * Only run the data synchronization in worker mode
             */
            if (__classPrivateFieldGet(this, _IndexModuleService_isWorkerMode, "f")) {
                this.dataSynchronizer_.onApplicationStart({
                    schemaObjectRepresentation: this.schemaObjectRepresentation_,
                    storageProvider: this.storageProvider_,
                });
                this.configurationChecker_ = new _utils_1.Configuration({
                    logger: this.logger_,
                    schemaObjectRepresentation: this.schemaObjectRepresentation_,
                    indexMetadataService: this.indexMetadataService_,
                    indexSyncService: this.indexSyncService_,
                    dataSynchronizer: this.dataSynchronizer_,
                });
                const entitiesMetadataChanged = await this.configurationChecker_.checkChanges();
                if (entitiesMetadataChanged.length) {
                    await this.dataSynchronizer_.syncEntities(entitiesMetadataChanged);
                }
            }
        }
        catch (e) {
            this.logger_.error(e);
        }
    }
    async query(config) {
        return await this.storageProvider_.query(config);
    }
    registerListeners() {
        if (!__classPrivateFieldGet(this, _IndexModuleService_isWorkerMode, "f")) {
            return;
        }
        const schemaObjectRepresentation = (this.schemaObjectRepresentation_ ??
            {});
        // Register entity event listeners
        for (const [entityName, schemaEntityObjectRepresentation] of Object.entries(schemaObjectRepresentation)) {
            if (_types_1.schemaObjectRepresentationPropertiesToOmit.includes(entityName)) {
                continue;
            }
            ;
            schemaEntityObjectRepresentation.listeners.forEach((listener) => {
                this.eventBusModuleService_.subscribe(listener, this.storageProvider_.consumeEvent(schemaEntityObjectRepresentation));
            });
        }
        // Register sync subscribers
        for (const { eventName, methodName } of Object.values(IndexModuleService.SyncSubscribersDescriptor)) {
            this.eventBusModuleService_.subscribe(eventName, this[methodName].bind(this));
        }
    }
    buildSchemaObjectRepresentation_() {
        if (this.schemaObjectRepresentation_) {
            return;
        }
        const { objectRepresentation, entitiesMap, executableSchema } = (0, _utils_1.buildSchemaObjectRepresentation)(base_graphql_schema_1.baseGraphqlSchema + (this.moduleOptions_.schema ?? _utils_1.defaultSchema));
        this.schemaObjectRepresentation_ = objectRepresentation;
        this.schemaEntitiesMap_ = entitiesMap;
        return executableSchema;
    }
    /**
     * Example output:
     *
     *
     * ```json
     * [
     *   {
     *     "id": "prod_123",
     *     "entity": "product",
     *     "status": "pending",
     *     "fields": ["id"],
     *     "updated_at": "<timestamp of last indexed data>",
     *     "last_synced_key": "prod_4321"
     *   },
     *   ...
     * ]
     * ```
     * @returns Detailed index metadata with the last synced key for each entity
     */
    async getInfo(sharedContext) {
        const listArguments = [
            {},
            {},
            sharedContext,
        ];
        const [indexMetadata, indexSync] = await (0, utils_1.promiseAll)([
            this.indexMetadataService_.list(...listArguments),
            this.indexSyncService_.list(...listArguments),
        ]);
        const lastEntitySyncedKeyMap = new Map(indexSync
            .filter((sync) => sync.last_key !== null)
            .map((sync) => [sync.entity, sync.last_key]));
        const indexInfo = indexMetadata.map((metadata) => {
            return {
                id: metadata.id,
                entity: metadata.entity,
                status: metadata.status,
                fields: metadata.fields.split(","),
                updated_at: metadata.updated_at,
                last_synced_key: lastEntitySyncedKeyMap.get(metadata.entity) ?? null,
            };
        });
        return indexInfo;
    }
    async sync({ strategy } = {}) {
        if (strategy && !["full", "reset"].includes(strategy)) {
            throw new Error(`Invalid sync strategy: ${strategy}. Must be "full" or "reset"`);
        }
        switch (strategy) {
            case "full":
                await this.fullSync();
                break;
            case "reset":
                await this.resetSync();
                break;
            default:
                await this.continueSync();
                break;
        }
    }
    /**
     * Continue the sync of the entities no matter their status
     * @param sharedContext
     * @returns
     */
    async continueSync() {
        if (!__classPrivateFieldGet(this, _IndexModuleService_isWorkerMode, "f")) {
            await this.baseRepository_.transaction(async (transactionManager) => {
                await this.indexMetadataService_.update({
                    selector: {
                        status: [
                            _utils_1.IndexMetadataStatus.DONE,
                            _utils_1.IndexMetadataStatus.ERROR,
                            _utils_1.IndexMetadataStatus.PROCESSING,
                        ],
                    },
                    data: {
                        status: _utils_1.IndexMetadataStatus.PENDING,
                    },
                }, { transactionManager });
                this.eventBusModuleService_.emit({
                    name: IndexModuleService.SyncSubscribersDescriptor.continueSync
                        .eventName,
                    data: {},
                    options: {
                        internal: true,
                    },
                });
            });
            return;
        }
        try {
            const entities = await this.configurationChecker_.checkChanges();
            if (!entities.length) {
                return;
            }
            return await this.dataSynchronizer_.syncEntities(entities);
        }
        catch (e) {
            this.logger_.error(e);
            throw new Error("[Index engine] Failed to continue sync");
        }
    }
    async fullSync() {
        if (!__classPrivateFieldGet(this, _IndexModuleService_isWorkerMode, "f")) {
            await this.baseRepository_.transaction(async (transactionManager) => {
                await (0, utils_1.promiseAll)([
                    this.indexMetadataService_.update({
                        selector: {
                            status: [
                                _utils_1.IndexMetadataStatus.DONE,
                                _utils_1.IndexMetadataStatus.ERROR,
                                _utils_1.IndexMetadataStatus.PROCESSING,
                            ],
                        },
                        data: {
                            status: _utils_1.IndexMetadataStatus.PENDING,
                        },
                    }, { transactionManager }),
                    this.indexSyncService_.update({
                        selector: { last_key: { $ne: null } },
                        data: { last_key: null },
                    }, { transactionManager }),
                ]);
                await this.eventBusModuleService_.emit({
                    name: IndexModuleService.SyncSubscribersDescriptor.fullSync.eventName,
                    data: {},
                    options: {
                        internal: true,
                    },
                });
            });
            return;
        }
        try {
            const entities = await this.configurationChecker_.checkChanges();
            if (!entities.length) {
                return;
            }
            return await this.dataSynchronizer_.syncEntities(entities);
        }
        catch (e) {
            this.logger_.error(e);
            throw new Error("[Index engine] Failed to full sync");
        }
    }
    async resetSync() {
        if (!__classPrivateFieldGet(this, _IndexModuleService_isWorkerMode, "f")) {
            await this.baseRepository_.transaction(async (transactionManager) => {
                const truncableTables = [
                    (0, utils_1.toMikroORMEntity)(_models_1.IndexData).prototype,
                    (0, utils_1.toMikroORMEntity)(_models_1.IndexRelation).prototype,
                    (0, utils_1.toMikroORMEntity)(_models_1.IndexMetadata).prototype,
                    (0, utils_1.toMikroORMEntity)(_models_1.IndexSync).prototype,
                ].map((table) => table.__helper.__meta.collection);
                await transactionManager.execute(`TRUNCATE TABLE ${truncableTables.join(", ")} CASCADE`);
                await this.eventBusModuleService_.emit({
                    name: IndexModuleService.SyncSubscribersDescriptor.resetSync
                        .eventName,
                    data: {},
                    options: {
                        internal: true,
                    },
                });
            });
            return;
        }
        try {
            const changes = await this.configurationChecker_.checkChanges();
            if (!changes.length) {
                return;
            }
            await this.dataSynchronizer_.syncEntities(changes);
        }
        catch (e) {
            this.logger_.error(e);
            throw new Error("[Index engine] Failed to reset sync");
        }
    }
}
_IndexModuleService_isWorkerMode = new WeakMap();
IndexModuleService.SyncSubscribersDescriptor = {
    continueSync: {
        eventName: "index.continue-sync",
        methodName: "continueSync",
    },
    fullSync: { eventName: "index.full-sync", methodName: "fullSync" },
    resetSync: { eventName: "index.reset-sync", methodName: "resetSync" },
};
exports.default = IndexModuleService;
__decorate([
    (0, utils_1.InjectManager)(),
    __param(0, (0, utils_1.MedusaContext)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], IndexModuleService.prototype, "getInfo", null);
//# sourceMappingURL=index-module-service.js.map